ada error :

Failed to set cookie: Error: Failed to parse or set cookie named "WorkosCursorSessionToken". [object Object]
Context
services/account.js
Stack Trace
services/account.js:101 (anonymous function)
// Account Management Service untuk Cursor Account Manager
class AccountService {
  constructor() {
    this.STORAGE_KEY = "cursor_accounts";
    this.AVATARS_KEY = "cursor_accounts:avatars";
    this.ACTIVE_KEY = "cursor_active_account";
    this.ACCOUNT_INFO_KEY = "cursor_accounts:info";
  }

  // Get all accounts
  async getAll() {
    const accounts = await chrome.storage.local.get(this.STORAGE_KEY);
    const avatars = await chrome.storage.local.get(this.AVATARS_KEY);
    const accountInfo = await chrome.storage.local.get(this.ACCOUNT_INFO_KEY);
    const activeAccount = await this.getActiveAccount();

    if (!accounts[this.STORAGE_KEY]) {
      return [];
    }

    return Object.entries(accounts[this.STORAGE_KEY]).map(([name, cookies]) => {
      const info = accountInfo[this.ACCOUNT_INFO_KEY]?.[name] || {};
      return {
        name,
        cookies,
        active: name === activeAccount,
        avatarUrl: avatars[this.AVATARS_KEY]?.[name] || null,
        expiresAt: this.getEarliestExpiry(cookies),
        email: info.email || name,
        status: info.status || "free",
      };
    });
  }

  // Get account names only
  async getAllNames() {
    const accounts = await this.getAll();
    return accounts.map((acc) => acc.name);
  }

  // Find specific account
  async find(accountName) {
    const accounts = await this.getAll();
    return accounts.find((acc) => acc.name === accountName);
  }

  // Get active account
  async getActiveAccount() {
    const result = await chrome.storage.local.get(this.ACTIVE_KEY);
    return result[this.ACTIVE_KEY] || null;
  }

  // Save or update account
  async upsert(accountName, cookies) {
    const accounts = await chrome.storage.local.get(this.STORAGE_KEY);
    const accountsData = accounts[this.STORAGE_KEY] || {};

    accountsData[accountName] = cookies;

    await chrome.storage.local.set({
      [this.STORAGE_KEY]: accountsData,
    });

    // Set as active if it's the first account
    const currentActive = await this.getActiveAccount();
    if (!currentActive) {
      await this.setActiveAccount(accountName);
    }
  }

  // Switch to account
  async switchTo(accountName) {
    const account = await this.find(accountName);
    if (!account) {
      throw new Error(`Account ${accountName} not found`);
    }

    // Clear all Cursor cookies
    await this.clearCursorCookies();

    // Restore cookies for target account
    for (const cookie of account.cookies) {
      const cookieData = {
        url: `https://${cookie.domain}${cookie.path}`,
        name: cookie.name,
        value: cookie.value,
        domain: cookie.domain,
        path: cookie.path,
        secure: cookie.secure,
        httpOnly: cookie.httpOnly,
        sameSite: cookie.sameSite || "unspecified",
      };

      if (cookie.expirationDate) {
        cookieData.expirationDate = cookie.expirationDate;
      }

      try {
        await chrome.cookies.set(cookieData);
      } catch (error) {
        console.error("Failed to set cookie:", error, cookieData);
      }
    }

    // Update active account
    await this.setActiveAccount(accountName);

    // Update badge
    await this.updateBadge(accountName);

    // Reload Cursor tabs
    await this.reloadCursorTabs();
  }

  // Remove account
  async remove(accountName) {
    const accounts = await chrome.storage.local.get(this.STORAGE_KEY);
    const accountsData = accounts[this.STORAGE_KEY] || {};

    delete accountsData[accountName];

    await chrome.storage.local.set({
      [this.STORAGE_KEY]: accountsData,
    });

    // Remove avatar
    const avatars = await chrome.storage.local.get(this.AVATARS_KEY);
    const avatarsData = avatars[this.AVATARS_KEY] || {};
    delete avatarsData[accountName];
    await chrome.storage.local.set({
      [this.AVATARS_KEY]: avatarsData,
    });

    // If this was active account, clear active status
    const activeAccount = await this.getActiveAccount();
    if (activeAccount === accountName) {
      await chrome.storage.local.remove(this.ACTIVE_KEY);
      await this.updateBadge("");
    }
  }

  // Save avatar for account
  async saveAvatar(accountName, avatarUrl) {
    const avatars = await chrome.storage.local.get(this.AVATARS_KEY);
    const avatarsData = avatars[this.AVATARS_KEY] || {};

    avatarsData[accountName] = avatarUrl;

    await chrome.storage.local.set({
      [this.AVATARS_KEY]: avatarsData,
    });
  }

  // Save account info (email and status)
  async saveAccountInfo(accountName, email, status) {
    const accountInfo = await chrome.storage.local.get(this.ACCOUNT_INFO_KEY);
    const infoData = accountInfo[this.ACCOUNT_INFO_KEY] || {};

    infoData[accountName] = { email, status };

    await chrome.storage.local.set({
      [this.ACCOUNT_INFO_KEY]: infoData,
    });
  }

  // Set active account
  async setActiveAccount(accountName) {
    await chrome.storage.local.set({
      [this.ACTIVE_KEY]: accountName,
    });
  }

  // Clear all Cursor cookies
  async clearCursorCookies() {
    try {
      const cursorCookies = await this.getCurrentCookies();
      console.log("Clearing", cursorCookies.length, "cursor cookies");

      for (const cookie of cursorCookies) {
        const domain = cookie.domain.startsWith(".")
          ? cookie.domain.substring(1)
          : cookie.domain;
        const url = `https://${domain}${cookie.path}`;

        try {
          await chrome.cookies.remove({
            url: url,
            name: cookie.name,
          });
        } catch (error) {
          console.error("Failed to remove cookie:", cookie.name, error);
        }
      }
    } catch (error) {
      console.error("Error clearing cookies:", error);
    }
  }

  // Get current Cursor cookies
  async getCurrentCookies() {
    try {
      // Get all cookies and filter for cursor.com
      const allCookies = await chrome.cookies.getAll({});

      // Filter cookies that belong to cursor.com
      const cursorCookies = allCookies.filter(
        (cookie) =>
          cookie.domain === "cursor.com" ||
          cookie.domain === ".cursor.com" ||
          cookie.domain.endsWith(".cursor.com")
      );

      console.log("Total cookies found:", allCookies.length);
      console.log("Cursor cookies found:", cursorCookies.length);

      return cursorCookies;
    } catch (error) {
      console.error("Error getting cookies:", error);
      return [];
    }
  }

  // Update extension badge
  async updateBadge(accountName) {
    if (accountName) {
      const shortName = accountName.substring(0, 2).toUpperCase();
      await chrome.action.setBadgeText({ text: shortName });
      await chrome.action.setBadgeBackgroundColor({ color: "#4CAF50" });
    } else {
      await chrome.action.setBadgeText({ text: "" });
    }
  }

  // Reload all Cursor tabs and redirect to dashboard
  async reloadCursorTabs() {
    const tabs = await chrome.tabs.query({
      url: ["https://*.cursor.com/*", "https://cursor.com/*"],
    });

    for (const tab of tabs) {
      // Redirect to dashboard instead of just reloading
      chrome.tabs.update(tab.id, { url: "https://cursor.com/dashboard" });
    }

    // If no cursor tabs are open, create a new one
    if (tabs.length === 0) {
      chrome.tabs.create({ url: "https://cursor.com/dashboard" });
    }
  }

  // Get earliest cookie expiry
  getEarliestExpiry(cookies) {
    const expiryDates = cookies
      .filter((cookie) => cookie.expirationDate)
      .map((cookie) => new Date(cookie.expirationDate * 1000));

    if (expiryDates.length === 0) return null;

    return new Date(Math.min(...expiryDates));
  }

  // Extract username from cookies or page
  async extractUsername() {
    const cookies = await this.getCurrentCookies();

    // Try to extract from cookie value (sesuai format di contoh)
    const sessionCookie = cookies.find(
      (c) => c.name === "WorkosCursorSessionToken"
    );
    if (sessionCookie) {
      // Extract user ID from cookie value
      const match = sessionCookie.value.match(/user_([A-Z0-9]+)/);
      if (match) {
        return match[1];
      }
    }

    // Fallback: use timestamp
    return `user_${Date.now()}`;
  }

  // Auto detect and save current account
  async autoDetectAccount() {
    const cookies = await this.getCurrentCookies();
    if (cookies.length === 0) return null;

    const username = await this.extractUsername();
    await this.upsert(username, cookies);

    return username;
  }

  // Generate random account name
  generateAccountName() {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    return `account_${timestamp}_${random}`;
  }

  // Export account to file
  async exportAccountToFile(accountName) {
    const account = await this.find(accountName);
    if (!account) throw new Error("Account not found");

    const exportData = {
      version: "1.0",
      extension: "cursor-account-manager",
      exportDate: new Date().toISOString(),
      account: {
        name: account.name,
        email: account.email,
        status: account.status,
        cookies: account.cookies,
        expiresAt: account.expiresAt,
      },
    };

    const filename = `cursor_accounts/${account.email || account.name}.json`;
    const blob = new Blob([JSON.stringify(exportData, null, 2)], {
      type: "application/json",
    });

    // Create data URL
    const reader = new FileReader();
    return new Promise((resolve, reject) => {
      reader.onloadend = () => {
        const dataUrl = reader.result;

        // Use Chrome downloads API
        chrome.downloads.download(
          {
            url: dataUrl,
            filename: filename,
            saveAs: false,
          },
          (downloadId) => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError);
            } else {
              // Store download ID for later reveal
              this.saveDownloadId(account.name, downloadId);
              resolve(downloadId);
            }
          }
        );
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  // Save download ID for account
  async saveDownloadId(accountName, downloadId) {
    const downloads = await chrome.storage.local.get("account_downloads");
    const downloadsData = downloads.account_downloads || {};

    downloadsData[accountName] = downloadId;

    await chrome.storage.local.set({
      account_downloads: downloadsData,
    });
  }

  // Get download ID for account
  async getDownloadId(accountName) {
    const downloads = await chrome.storage.local.get("account_downloads");
    const downloadsData = downloads.account_downloads || {};
    return downloadsData[accountName] || null;
  }

  // Reveal account file in explorer
  async revealAccountFile(accountName) {
    try {
      const downloadId = await this.getDownloadId(accountName);
      if (downloadId) {
        // Show file in folder
        chrome.downloads.show(downloadId);
        return true;
      } else {
        // Try to find file by searching downloads
        const downloads = await new Promise((resolve, reject) => {
          chrome.downloads.search(
            {
              filenameRegex: `cursor_accounts/${accountName}\\.json$|cursor_accounts/.*${accountName}.*\\.json$`,
              exists: true,
            },
            (results) => {
              if (chrome.runtime.lastError) {
                reject(chrome.runtime.lastError);
              } else {
                resolve(results);
              }
            }
          );
        });

        if (downloads && downloads.length > 0) {
          chrome.downloads.show(downloads[0].id);
          return true;
        }

        return false;
      }
    } catch (error) {
      console.error("Error revealing file:", error);
      return false;
    }
  }

  // Import account from JSON text
  async importAccountFromJSON(jsonText, customName = null) {
    try {
      const data = JSON.parse(jsonText);

      // Support both single cookie array and full export format
      let cookies, email, status, name;

      if (Array.isArray(data)) {
        // Direct cookie array
        cookies = data;
        name = customName || this.generateAccountName();
        email = name;
        status = "free";
      } else if (data.account) {
        // Full export format
        cookies = data.account.cookies;
        email = data.account.email || data.account.name;
        status = data.account.status || "free";
        name = customName || data.account.name || this.generateAccountName();
      } else {
        throw new Error("Invalid JSON format");
      }

      // Save account
      await this.upsert(name, cookies);
      await this.saveAccountInfo(name, email, status);

      // Export to file (only if not already from file)
      if (!data.account) {
        await this.exportAccountToFile(name);
      }

      return name;
    } catch (error) {
      console.error("Import error:", error);
      throw error;
    }
  }

  // Scan Downloads folder for account files
  async scanDownloadsForAccounts() {
    try {
      // Request permission to access downloads
      const hasPermission = await new Promise((resolve) => {
        chrome.permissions.contains(
          {
            permissions: ["downloads"],
          },
          resolve
        );
      });

      if (!hasPermission) {
        console.log("Downloads permission not available");
        return [];
      }

      // Search for account files in Downloads/cursor_accounts/
      const downloads = await new Promise((resolve, reject) => {
        chrome.downloads.search(
          {
            filenameRegex: "cursor_accounts/.*\\.json$",
            exists: true,
          },
          (results) => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError);
            } else {
              resolve(results);
            }
          }
        );
      });

      console.log("Found download files:", downloads.length);
      return downloads;
    } catch (error) {
      console.error("Error scanning downloads:", error);
      return [];
    }
  }

  // Load accounts from Downloads folder
  async loadAccountsFromDownloads() {
    try {
      const downloadFiles = await this.scanDownloadsForAccounts();
      let importedCount = 0;

      for (const file of downloadFiles) {
        try {
          // Read file content (this is limited by browser security)
          // We can only suggest to user to manually import these files
          console.log("Found account file:", file.filename);
        } catch (error) {
          console.error("Error reading file:", file.filename, error);
        }
      }

      return importedCount;
    } catch (error) {
      console.error("Error loading from downloads:", error);
      return 0;
    }
  }
}

// Export instance
const accountService = new AccountService();

// For service worker context
if (typeof self !== "undefined") {
  self.accountService = accountService;
}
 

Uncaught (in promise) Error: No tab with id: 1267706024.
Context
background.js
Stack Trace
background.js:0 (anonymous function)

Error opening sidebar: TypeError: Cannot read properties of undefined (reading 'open')
Context
popup.html
Stack Trace
popup.js:631 (toggleSidebarMode)
popup.js:68 (anonymous function)

// Cursor Account Manager - Popup Script

class CursorAccountManager {
  constructor() {
    this.accounts = [];
    this.activeAccount = null;
    this.infoUpdated = false;
    this.init();
  }

  async init() {
    // Check Chrome version for Side Panel support
    this.checkSidePanelSupport();

    // Load accounts and active account
    await this.loadAccounts();

    // Setup event listeners
    this.setupEventListeners();

    // Update UI
    this.updateUI();
  }

  checkSidePanelSupport() {
    const sidebarBtn = document.getElementById("sidebarModeToggle");

    if (!chrome.sidePanel) {
      // Disable sidebar button if not supported
      sidebarBtn.style.opacity = "0.5";
      sidebarBtn.title = "Side Panel requires Chrome 114+";
      console.log("Side Panel not supported in this Chrome version");
    } else {
      console.log("Side Panel API available");
    }
  }

  setupEventListeners() {
    // Add account button
    document.getElementById("addAccountBtn").addEventListener("click", () => {
      this.showAddAccountModal();
    });

    // Export current button
    document
      .getElementById("exportCurrentBtn")
      .addEventListener("click", () => {
        this.exportCurrentAccount();
      });

    // Import from Downloads button
    document
      .getElementById("importFromDownloadsBtn")
      .addEventListener("click", () => {
        this.importFromDownloads();
      });

    // Import Folder button
    document.getElementById("importFolderBtn").addEventListener("click", () => {
      this.importFromFolder();
    });

    // Downloads file input change
    document
      .getElementById("downloadsFileInput")
      .addEventListener("change", (e) => {
        this.handleDownloadsImport(e.target.files);
      });

    // Folder input change
    document.getElementById("folderInput").addEventListener("change", (e) => {
      this.handleFolderImport(e.target.files);
    });

    // Refresh button
    document.getElementById("refreshBtn").addEventListener("click", () => {
      this.loadAccounts();
    });

    // Sidebar mode toggle
    document
      .getElementById("sidebarModeToggle")
      .addEventListener("click", () => {
        this.toggleSidebarMode();
      });

    // Dark mode toggle
    document.getElementById("darkModeToggle").addEventListener("click", () => {
      this.toggleDarkMode();
    });

    // Modal controls
    document.getElementById("closeModal").addEventListener("click", () => {
      this.hideModal();
    });

    document.getElementById("cancelAddBtn").addEventListener("click", () => {
      this.hideModal();
    });

    document.getElementById("confirmAddBtn").addEventListener("click", () => {
      this.addAccountFromJSON();
    });
  }

  async loadAccounts() {
    try {
      this.showLoading(true);

      // Check if background script is ready
      const ping = await chrome.runtime
        .sendMessage({ type: "ping" })
        .catch(() => null);
      if (!ping) {
        console.error("Background script not responding");
        setTimeout(() => this.loadAccounts(), 500);
        return;
      }

      // Get accounts from background
      const response = await chrome.runtime.sendMessage({
        type: "getAccounts",
      });

      if (response && response.success) {
        this.accounts = response.data || [];

        // Get active account
        const activeResponse = await chrome.runtime.sendMessage({
          type: "getActiveAccount",
        });
        this.activeAccount = activeResponse?.data || null;

        // Try to update account info if needed
        if (this.activeAccount) {
          this.updateAccountInfo();
        }

        this.updateUI();
      } else {
        this.showNotification("Failed to load accounts", "error");
        this.accounts = [];
        this.updateUI();
      }
    } catch (error) {
      console.error("Error loading accounts:", error);
      this.showNotification("Extension error: Please reload", "error");
      this.accounts = [];
      this.updateUI();
    } finally {
      this.showLoading(false);
    }
  }

  async updateAccountInfo() {
    // Only update if we have an active account and it looks like a generated name
    if (this.activeAccount) {
      // Check if this account already has proper email info
      const currentAccount = this.accounts.find(
        (acc) => acc.name === this.activeAccount
      );

      // Skip if we already have a proper email (not the same as the account name)
      if (
        currentAccount &&
        currentAccount.email &&
        currentAccount.email !== this.activeAccount &&
        currentAccount.email.includes("@")
      ) {
        return; // Already has proper info, no need to update
      }

      try {
        const infoResponse = await chrome.runtime.sendMessage({
          type: "getAccountInfo",
        });

        if (infoResponse && infoResponse.success && infoResponse.data) {
          const { email, status } = infoResponse.data;
          // Only update if we got valid email
          if (email && email.includes("@")) {
            await chrome.runtime.sendMessage({
              type: "updateAccountInfo",
              account: this.activeAccount,
              email: email,
              status: status || "free",
            });
            // Reload to show updated info
            setTimeout(() => {
              this.infoUpdated = true; // Prevent loop
              this.loadAccounts();
            }, 500);
          }
        }
      } catch (error) {
        // Silently fail if we can't get account info
        console.log("Could not update account info:", error);
      }
    }
  }

  updateUI() {
    // Update current account display
    this.updateCurrentAccount();

    // Update accounts list
    this.updateAccountsList();

    // Update accounts count
    document.getElementById(
      "accountsCount"
    ).textContent = `(${this.accounts.length})`;
  }

  updateCurrentAccount() {
    const currentAccountEl = document.getElementById("currentAccount");
    const activeAccount = this.accounts.find((acc) => acc.active);

    if (activeAccount) {
      currentAccountEl.innerHTML = `
        <span class="account-icon">🟢</span>
        <span class="account-name">${this.escapeHtml(
          activeAccount.email
        )}</span>
      `;
    } else {
      currentAccountEl.innerHTML = `
        <span class="account-icon">🔴</span>
        <span class="account-name">Not logged in</span>
      `;
    }
  }

  updateAccountsList() {
    const listEl = document.getElementById("accountsList");
    const emptyEl = document.getElementById("noAccounts");

    if (this.accounts.length === 0) {
      listEl.style.display = "none";
      emptyEl.style.display = "block";
      return;
    }

    listEl.style.display = "block";
    emptyEl.style.display = "none";
    listEl.innerHTML = "";

    // Sort accounts - active first
    const sortedAccounts = [...this.accounts].sort((a, b) => {
      if (a.active) return -1;
      if (b.active) return 1;
      return a.email.localeCompare(b.email);
    });

    sortedAccounts.forEach((account) => {
      const accountEl = this.createAccountElement(account);
      listEl.appendChild(accountEl);
    });
  }

  createAccountElement(account) {
    const template = document.getElementById("accountTemplate");
    const element = template.content.cloneNode(true);
    const container = element.querySelector(".account-item");

    // Set account data
    container.dataset.account = account.name;

    // Set email
    container.querySelector(".account-email").textContent = account.email;

    // Set status
    const statusEl = container.querySelector(".account-status");
    statusEl.textContent = account.status;
    statusEl.className = `account-status ${account.status}`;

    // Hide expiry element - we don't need it anymore
    const expiryEl = container.querySelector(".account-expiry");
    expiryEl.style.display = "none";

    // Show/hide active indicator
    const activeIndicator = container.querySelector(".active-indicator");
    if (account.active) {
      activeIndicator.style.display = "block";
      container.classList.add("active");
    } else {
      activeIndicator.style.display = "none";

      // Make whole card clickable for switching
      container.addEventListener("click", (e) => {
        if (!e.target.closest(".delete-btn")) {
          this.switchAccount(account.name);
        }
      });
    }

    // Setup reveal button
    container.querySelector(".reveal-btn").addEventListener("click", (e) => {
      e.stopPropagation();
      this.revealAccountFile(account.name);
    });

    // Setup delete button
    container.querySelector(".delete-btn").addEventListener("click", (e) => {
      e.stopPropagation();
      this.deleteAccount(account.name);
    });

    return container;
  }

  showAddAccountModal() {
    document.getElementById("addAccountModal").style.display = "block";
    document.getElementById("cookiesInput").value = "";
    document.getElementById("accountNameInput").value = "";
    document.getElementById("cookiesInput").focus();

    // Clear any existing duplicate warnings
    const existingWarning = document.querySelector(".duplicate-warning");
    if (existingWarning) {
      existingWarning.remove();
    }
  }

  hideModal() {
    document.getElementById("addAccountModal").style.display = "none";
    // Clear any duplicate warnings
    const existingWarning = document.querySelector(".duplicate-warning");
    if (existingWarning) {
      existingWarning.remove();
    }
  }

  // Show duplicate account warning inside modal
  showDuplicateWarning(existingAccount) {
    // Remove any existing warning
    const existingWarning = document.querySelector(".duplicate-warning");
    if (existingWarning) {
      existingWarning.remove();
    }

    // Create warning element
    const warning = document.createElement("div");
    warning.className = "duplicate-warning";
    warning.style.cssText = `
      background: #fee2e2;
      border: 1px solid #fca5a5;
      border-radius: 6px;
      padding: 12px;
      margin: 12px 0;
      color: #dc2626;
      font-size: 14px;
    `;
    warning.innerHTML = `
      <strong>⚠️ Account Already Exists</strong><br>
      This account is already saved as: <strong>${
        existingAccount.email || existingAccount.name
      }</strong>
    `;

    // Insert warning after the textarea
    const textarea = document.getElementById("cookiesInput");
    textarea.parentNode.insertBefore(warning, textarea.nextSibling);
  }

  // Check if account already exists by comparing session tokens
  async findExistingAccount(newCookies) {
    // Extract session token from new cookies
    const newSessionToken = this.extractSessionToken(newCookies);
    if (!newSessionToken) return null;

    // Check against existing accounts
    for (const account of this.accounts) {
      const existingSessionToken = this.extractSessionToken(account.cookies);
      if (existingSessionToken && existingSessionToken === newSessionToken) {
        return account;
      }
    }
    return null;
  }

  // Extract session token from cookies
  extractSessionToken(cookies) {
    const sessionCookie = cookies.find(
      (c) => c.name === "WorkosCursorSessionToken" || c.name === "SessionToken"
    );
    return sessionCookie ? sessionCookie.value : null;
  }

  async addAccountFromJSON() {
    const cookiesInput = document.getElementById("cookiesInput").value.trim();
    const accountName = document
      .getElementById("accountNameInput")
      .value.trim();

    if (!cookiesInput) {
      this.showNotification("Please paste cookies JSON", "error");
      return;
    }

    try {
      this.showLoading(true);

      // Validate JSON
      const cookiesData = JSON.parse(cookiesInput);

      // Check if account already exists by comparing cookies
      const existingAccount = await this.findExistingAccount(cookiesData);
      if (existingAccount) {
        this.showDuplicateWarning(existingAccount);
        return;
      }

      const response = await chrome.runtime.sendMessage({
        type: "importAccountJSON",
        jsonText: cookiesInput,
        customName: accountName || null,
      });

      if (response.success) {
        this.showNotification(`Added account: ${response.data}`, "success");
        this.hideModal();
        await this.loadAccounts();
      } else {
        this.showNotification(
          response.error || "Failed to add account",
          "error"
        );
      }
    } catch (error) {
      console.error("Error adding account:", error);
      this.showNotification("Invalid JSON format", "error");
    } finally {
      this.showLoading(false);
    }
  }

  async exportCurrentAccount() {
    if (!this.activeAccount) {
      this.showNotification("No active account to export", "error");
      return;
    }

    try {
      this.showLoading(true);

      const response = await chrome.runtime.sendMessage({
        type: "exportAccount",
        account: this.activeAccount,
      });

      if (response.success) {
        this.showNotification("Account exported to Downloads", "success");
      } else {
        this.showNotification(
          response.error || "Failed to export account",
          "error"
        );
      }
    } catch (error) {
      console.error("Error exporting account:", error);
      this.showNotification("Error exporting account", "error");
    } finally {
      this.showLoading(false);
    }
  }

  async switchAccount(accountName) {
    if (confirm(`Switch to account ${accountName}?`)) {
      try {
        this.showLoading(true);

        const response = await chrome.runtime.sendMessage({
          type: "switchAccount",
          account: accountName,
        });

        if (response.success) {
          this.showNotification(`Switching to ${accountName}...`, "success");
          // Close popup and let background script handle redirect
          setTimeout(() => {
            window.close();
            // Check if switch was successful after a delay
            setTimeout(() => this.checkSwitchSuccess(accountName), 3000);
          }, 500);
        } else {
          this.showNotification(
            response.error || "Failed to switch account",
            "error"
          );
        }
      } catch (error) {
        console.error("Error switching account:", error);
        this.showNotification("Error switching account", "error");
      } finally {
        this.showLoading(false);
      }
    }
  }

  // Check if account switch was successful
  async checkSwitchSuccess(expectedAccount) {
    try {
      // Check if switch was successful
      const response = await chrome.runtime.sendMessage({
        type: "checkSwitchSuccess",
        expectedAccount: expectedAccount,
      });

      if (response.success && !response.switchSuccessful) {
        // Show warning modal
        this.showSwitchFailureWarning(expectedAccount, response.currentActive);
      }
    } catch (error) {
      console.log("Could not verify switch success:", error);
    }
  }

  // Show warning modal for failed switch
  showSwitchFailureWarning(expectedAccount, currentAccount) {
    const modal = document.createElement("div");
    modal.className = "modal";
    modal.style.display = "block";

    const currentAccountText = currentAccount
      ? `Still logged in as: <strong>${currentAccount}</strong>`
      : "No active account detected";

    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-header">
          <h3>⚠️ Account Switch Issue</h3>
        </div>
        <div class="modal-body">
          <p>Failed to switch to: <strong>${expectedAccount}</strong></p>
          <p>${currentAccountText}</p>
          <br>
          <p><strong>This usually happens when browser cookies conflict.</strong></p>
          <p>To fix this issue:</p>
          <ol>
            <li>Clear your browser data (cookies and cache)</li>
            <li>Try switching accounts again</li>
          </ol>
          <p>Click the button below to open your browser's clear data settings:</p>
        </div>
        <div class="modal-footer">
          <button id="clearDataBtn" class="btn btn-primary">🧹 Clear Browser Data</button>
          <button id="dismissWarningBtn" class="btn btn-secondary">Dismiss</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // Event listeners
    modal.querySelector("#clearDataBtn").addEventListener("click", () => {
      this.openClearBrowserData();
      document.body.removeChild(modal);
    });

    modal.querySelector("#dismissWarningBtn").addEventListener("click", () => {
      document.body.removeChild(modal);
    });

    // Close on background click
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        document.body.removeChild(modal);
      }
    });
  }

  // Open browser's clear data settings
  async openClearBrowserData() {
    try {
      // Detect browser and open appropriate settings
      const userAgent = navigator.userAgent.toLowerCase();
      let settingsUrl;

      if (userAgent.includes("edg/")) {
        // Microsoft Edge
        settingsUrl = "edge://settings/clearBrowserData";
      } else if (userAgent.includes("brave/")) {
        // Brave Browser
        settingsUrl = "brave://settings/clearBrowserData";
      } else if (userAgent.includes("opr/") || userAgent.includes("opera/")) {
        // Opera
        settingsUrl = "opera://settings/clearBrowserData";
      } else if (userAgent.includes("chrome/")) {
        // Chrome or Chromium-based
        settingsUrl = "chrome://settings/clearBrowserData";
      } else {
        // Fallback to Chrome
        settingsUrl = "chrome://settings/clearBrowserData";
      }

      // Open in new tab
      chrome.tabs.create({ url: settingsUrl });

      this.showNotification(
        "Opening browser settings. Clear cookies and cache, then try again.",
        "info"
      );
    } catch (error) {
      console.error("Error opening clear data settings:", error);
      this.showNotification(
        "Please manually go to your browser settings and clear cookies/cache",
        "error"
      );
    }
  }

  async revealAccountFile(accountName) {
    try {
      const response = await chrome.runtime.sendMessage({
        type: "revealAccountFile",
        account: accountName,
      });

      if (response.success) {
        this.showNotification("File revealed in explorer", "success");
      } else {
        this.showNotification("File not found in Downloads", "error");
      }
    } catch (error) {
      console.error("Error revealing file:", error);
      this.showNotification("Error revealing file", "error");
    }
  }

  async deleteAccount(accountName) {
    if (!confirm(`Delete account ${accountName}?`)) {
      return;
    }

    try {
      this.showLoading(true);

      const response = await chrome.runtime.sendMessage({
        type: "removeAccount",
        account: accountName,
      });

      if (response.success) {
        this.showNotification(`Deleted account: ${accountName}`, "success");
        await this.loadAccounts();
      } else {
        this.showNotification(
          response.error || "Failed to delete account",
          "error"
        );
      }
    } catch (error) {
      console.error("Error deleting account:", error);
      this.showNotification("Error deleting account", "error");
    } finally {
      this.showLoading(false);
    }
  }

  async toggleSidebarMode() {
    try {
      // Simple test message first
      const testResponse = await chrome.runtime.sendMessage({
        type: "ping",
      });

      console.log("Test ping response:", testResponse);

      if (!testResponse.success) {
        this.showNotification("Background script not responding", "error");
        return;
      }

      // Now try sidebar
      const response = await chrome.runtime.sendMessage({
        type: "openSidePanel",
      });

      console.log("Sidebar response:", response);

      if (response && response.success) {
        if (response.message) {
          this.showNotification(response.message, "info");
        } else {
          this.showNotification("Opening sidebar...", "success");
          setTimeout(() => window.close(), 500);
        }
      } else {
        const errorMsg = response ? response.error : "No response";
        this.showNotification(`Sidebar error: ${errorMsg}`, "error");
      }
    } catch (error) {
      console.error("Error in toggleSidebarMode:", error);
      this.showNotification(`Error: ${error.message}`, "error");
    }
  }

  toggleDarkMode() {
    document.body.classList.toggle("dark-mode");
    const isDark = document.body.classList.contains("dark-mode");

    // Save preference
    chrome.storage.local.set({ darkMode: isDark });

    // Update button
    document.getElementById("darkModeToggle").textContent = isDark
      ? "☀️"
      : "🌙";
  }

  showLoading(show) {
    const overlay = document.getElementById("loadingOverlay");
    if (show) {
      overlay.style.display = "flex";
      // Auto hide after 1 second to prevent stuck loading
      this.loadingTimeout = setTimeout(() => {
        overlay.style.display = "none";
      }, 1000);
    } else {
      overlay.style.display = "none";
      // Clear any existing timeout
      if (this.loadingTimeout) {
        clearTimeout(this.loadingTimeout);
      }
    }
  }

  showNotification(message, type = "info") {
    const notification = document.getElementById("notification");
    const text = document.getElementById("notificationText");

    text.textContent = message;
    notification.className = `notification ${type}`;
    notification.style.display = "block";

    setTimeout(() => {
      notification.style.display = "none";
    }, 3000);
  }

  // Import from Downloads folder
  importFromDownloads() {
    document.getElementById("downloadsFileInput").click();
  }

  // Import from folder
  importFromFolder() {
    document.getElementById("folderInput").click();
  }

  // Handle multiple file import from Downloads
  async handleDownloadsImport(files) {
    await this.processFileImport(files, "downloadsFileInput");
  }

  // Handle folder import
  async handleFolderImport(files) {
    // Filter only JSON files from the folder
    const jsonFiles = Array.from(files).filter((file) =>
      file.name.toLowerCase().endsWith(".json")
    );

    if (jsonFiles.length === 0) {
      this.showNotification(
        "No JSON files found in the selected folder",
        "error"
      );
      return;
    }

    this.showNotification(
      `Found ${jsonFiles.length} JSON files in folder, importing...`,
      "info"
    );
    await this.processFileImport(jsonFiles, "folderInput");
  }

  // Process file import (shared by both methods)
  async processFileImport(files, inputId) {
    if (!files || files.length === 0) return;

    let importedCount = 0;
    let skippedCount = 0;
    let errorCount = 0;

    this.showLoading(true);

    try {
      for (const file of files) {
        try {
          // Skip non-JSON files
          if (!file.name.toLowerCase().endsWith(".json")) {
            continue;
          }

          const text = await file.text();
          const data = JSON.parse(text);

          // Check if it's a valid account file
          if (data.account || Array.isArray(data)) {
            // Check for duplicates
            const cookies = data.account ? data.account.cookies : data;
            const existingAccount = await this.findExistingAccount(cookies);

            if (existingAccount) {
              skippedCount++;
              console.log(`Skipped duplicate: ${file.name}`);
              continue;
            }

            // Import the account
            const response = await chrome.runtime.sendMessage({
              type: "importAccountJSON",
              jsonText: text,
              customName: null,
            });

            if (response.success) {
              importedCount++;
              console.log(`Imported: ${file.name} as ${response.data}`);
            } else {
              errorCount++;
              console.error(`Failed to import: ${file.name}`, response.error);
            }
          } else {
            errorCount++;
            console.log(`Invalid format: ${file.name}`);
          }
        } catch (error) {
          console.error("Error importing file:", file.name, error);
          errorCount++;
        }
      }

      // Show detailed results
      let message = `Import completed: ${importedCount} imported`;
      if (skippedCount > 0) {
        message += `, ${skippedCount} skipped (duplicates)`;
      }
      if (errorCount > 0) {
        message += `, ${errorCount} errors`;
      }

      this.showNotification(message, importedCount > 0 ? "success" : "info");

      if (importedCount > 0) {
        await this.loadAccounts();
      }
    } catch (error) {
      console.error("Error during bulk import:", error);
      this.showNotification("Error importing files", "error");
    } finally {
      this.showLoading(false);
      // Clear the file input
      document.getElementById(inputId).value = "";
    }
  }

  escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }
}

// Initialize when DOM is ready
document.addEventListener("DOMContentLoaded", () => {
  // Load dark mode preference
  chrome.storage.local.get(["darkMode"], (result) => {
    if (result.darkMode) {
      document.body.classList.add("dark-mode");
      document.getElementById("darkModeToggle").textContent = "☀️";
    }
  });

  // Initialize manager
  new CursorAccountManager();
});
 
Side panel error: Error: `sidePanel.open()` may only be called in response to a user gesture.
Context
background.js
Stack Trace
background.js:145 (anonymous function)

// Background script for Cursor Account Manager extension

// Import account service
importScripts("services/account.js");

// Initialize on install
chrome.runtime.onInstalled.addListener(async () => {
  console.log("Cursor Account Manager extension installed");

  try {
    // Enable side panel for all tabs (if supported)
    if (chrome.sidePanel) {
      console.log("Side Panel API available");
      await chrome.sidePanel.setPanelBehavior({
        openPanelOnActionClick: false,
      });
    } else {
      console.log("Side Panel API not available - requires Chrome 114+");
    }

    // Check if there's an active session
    const cookies = await accountService.getCurrentCookies();
    console.log("Found cookies:", cookies.length);

    if (cookies.length > 0) {
      const username = await accountService.autoDetectAccount();
      console.log("Auto-detected username:", username);

      if (username) {
        await accountService.updateBadge(username);
      }
    }
  } catch (error) {
    console.error("Error during initialization:", error);
  }
});

// Sync accounts when cookies change
chrome.cookies.onChanged.addListener(async (changeInfo) => {
  if (changeInfo.cookie.domain.includes("cursor.com")) {
    // If cookie was added and we don't have an active account, auto-detect
    if (!changeInfo.removed) {
      const activeAccount = await accountService.getActiveAccount();
      if (!activeAccount) {
        await accountService.autoDetectAccount();
      }
    }
  }
});

// Handle messages from popup and content scripts
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  (async () => {
    try {
      console.log("Received message:", request.type);
      switch (request.type) {
        case "ping":
          sendResponse({ success: true });
          break;

        case "getAccounts":
          const accounts = await accountService.getAll();
          sendResponse({ success: true, data: accounts });
          break;

        case "switchAccount":
          await accountService.switchTo(request.account);
          sendResponse({ success: true });
          break;

        case "removeAccount":
          await accountService.remove(request.account);
          sendResponse({ success: true });
          break;

        case "addCurrentAccount":
          const username = await accountService.autoDetectAccount();
          sendResponse({ success: true, data: username });
          break;

        case "getActiveAccount":
          const active = await accountService.getActiveAccount();
          sendResponse({ success: true, data: active });
          break;

        case "importAccount":
          await accountService.upsert(
            request.account.name,
            request.account.cookies
          );
          sendResponse({ success: true });
          break;

        case "checkSwitchSuccess":
          // Verify if the account switch was successful
          const currentActive = await accountService.getActiveAccount();
          const expectedAccount = request.expectedAccount;
          sendResponse({
            success: true,
            switchSuccessful: currentActive === expectedAccount,
            currentActive: currentActive,
          });
          break;

        case "scanDownloadsFolder":
          // Scan Downloads folder for account files
          const downloadFiles = await accountService.scanDownloadsForAccounts();
          sendResponse({ success: true, data: downloadFiles });
          break;

        case "openSidePanel":
          console.log("Processing openSidePanel request");
          // Open side panel
          try {
            console.log("chrome.sidePanel available:", !!chrome.sidePanel);
            console.log(
              "chrome.sidePanel.open available:",
              !!(chrome.sidePanel && chrome.sidePanel.open)
            );

            if (chrome.sidePanel && chrome.sidePanel.open) {
              console.log("Attempting to open side panel...");
              const currentWindow = await chrome.windows.getCurrent();
              await chrome.sidePanel.open({ windowId: currentWindow.id });
              console.log("Side panel opened successfully");
              sendResponse({ success: true });
            } else if (chrome.sidePanel) {
              console.log("Using fallback: setPanelBehavior");
              // Fallback: enable side panel behavior
              await chrome.sidePanel.setPanelBehavior({
                openPanelOnActionClick: true,
              });
              sendResponse({
                success: true,
                message: "Side panel enabled. Click extension icon again.",
              });
            } else {
              console.log("Side Panel API not available");
              sendResponse({
                success: false,
                error: "Side Panel API not available in this Chrome version",
              });
            }
          } catch (error) {
            console.error("Side panel error:", error);
            sendResponse({ success: false, error: error.message });
          }
          break;

        case "importAccountJSON":
          const accountName = await accountService.importAccountFromJSON(
            request.jsonText,
            request.customName
          );
          sendResponse({ success: true, data: accountName });
          break;

        case "exportAccount":
          await accountService.exportAccountToFile(request.account);
          sendResponse({ success: true });
          break;

        case "revealAccountFile":
          const revealed = await accountService.revealAccountFile(
            request.account
          );
          sendResponse({ success: revealed });
          break;

        case "updateAccountInfo":
          await accountService.saveAccountInfo(
            request.account,
            request.email,
            request.status
          );
          sendResponse({ success: true });
          break;

        case "getAccountInfo":
          // Extract info from current page
          const [tab] = await chrome.tabs.query({
            active: true,
            currentWindow: true,
          });
          // Only process if we're on cursor.com/dashboard or settings
          if (
            tab &&
            tab.url &&
            (tab.url.includes("cursor.com/dashboard") ||
              tab.url.includes("cursor.com/settings"))
          ) {
            const result = await chrome.scripting.executeScript({
              target: { tabId: tab.id },
              func: () => {
                // This runs in the page context
                const extractInfo = () => {
                  let email = null;
                  let status = "unknown";

                  // Find email
                  const emailEls = document.querySelectorAll(
                    'p.truncate.text-sm.font-medium, [class*="truncate"][class*="font-medium"]'
                  );
                  for (const el of emailEls) {
                    const text = el.textContent.trim();
                    if (text && text.includes("@")) {
                      email = text;
                      break;
                    }
                  }

                  // Find status - try multiple selectors
                  const statusSelectors = [
                    "p.flex-shrink-0.text-sm.text-brand-gray-300",
                    '[class*="text-brand-gray-300"]',
                    'div[title*="Plan"] p',
                    'div[title*="plan"] p',
                    "div.flex.min-w-0.items-center.gap-1 p",
                  ];

                  for (const selector of statusSelectors) {
                    const statusEls = document.querySelectorAll(selector);
                    for (const el of statusEls) {
                      const text = el.textContent.trim().toLowerCase();
                      if (text) {
                        // Handle variations like "Free Plan", "Pro Plan", etc.
                        if (text.includes("free")) {
                          status = "free";
                          break;
                        } else if (text.includes("pro")) {
                          status = "pro";
                          break;
                        } else if (text.includes("business")) {
                          status = "business";
                          break;
                        }
                      }
                    }
                    if (status !== "unknown") break;
                  }

                  // Fallback: check title attributes directly
                  if (status === "unknown") {
                    const titleEls = document.querySelectorAll(
                      '[title*="Plan"], [title*="plan"]'
                    );
                    for (const el of titleEls) {
                      const title = el.getAttribute("title").toLowerCase();
                      if (title.includes("free")) {
                        status = "free";
                        break;
                      } else if (title.includes("pro")) {
                        status = "pro";
                        break;
                      } else if (title.includes("business")) {
                        status = "business";
                        break;
                      }
                    }
                  }

                  return { email, status };
                };

                return extractInfo();
              },
            });

            if (result && result[0] && result[0].result) {
              sendResponse({ success: true, data: result[0].result });
            } else {
              sendResponse({ success: false, error: "Could not extract info" });
            }
          } else {
            sendResponse({ success: false, error: "Not on cursor.com" });
          }
          break;

        default:
          sendResponse({ success: false, error: "Unknown message type" });
      }
    } catch (error) {
      sendResponse({ success: false, error: error.message });
    }
  })();

  return true; // Keep channel open for async response
});

// Update badge on startup
chrome.runtime.onStartup.addListener(async () => {
  const activeAccount = await accountService.getActiveAccount();
  if (activeAccount) {
    await accountService.updateBadge(activeAccount);
  }
});
 

setiap akun aku coba klik muncul "File not found in Downloads" , dan Sidebar error: `sidePanel.open()` may only be called in response to a user gesture.
